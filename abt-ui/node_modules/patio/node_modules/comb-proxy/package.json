{
  "name": "comb-proxy",
  "description": "A framework for node",
  "version": "0.0.3",
  "keywords": [
    "comb",
    "Proxy"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:C2FO/comb-proxy.git"
  },
  "dependencies": {
    "node-proxy": ">=0.6.0"
  },
  "devDependencies": {
    "comb": ">=0.1.2"
  },
  "author": {
    "name": "Doug Martin",
    "url": "http://c2fo.github.com"
  },
  "main": "index.js",
  "directories": {
    "lib": "lib"
  },
  "engines": {
    "node": ">= 0.6.1"
  },
  "readme": "<a name=\"top\"></a>\n\n\n  <h1>comb-proxy</h1>\n\n<h2>Overview</h2>\n<p>\n     Comb-proxy is plugin for comb to expose ProxyHelpers.\n</p>\n\n<h2> Installation</h2>\n\n```javascript\n npm install comb-proxy\n```\n\n\n<h2>Usage</h2>\n\nTo initialize comb-proxy simply require it.\n\n```javascript\n\nvar comb = require(\"comb-proxy\");\n\n```\n\n##Namespaces\n\n\n\n  * [comb](#comb)\n\n\n\n##Classes\n\n\n\n  * [comb.plugins.MethodMissing](#comb_plugins_MethodMissing)\n\n\n<a name=\"comb\"></a>\n##comb\n\n[Top](#top)\n\n\nAlias for comb.\n\n\n  * [createFunctionWrapper](#comb_createFunctionWrapper)\n\n  * [executeInOrder](#comb_executeInOrder)\n\n  * [handlerProxy](#comb_handlerProxy)\n\n  * [isProxy](#comb_isProxy)\n\n  * [methodMissing](#comb_methodMissing)\n\n\n  \n<a name=\"comb_createFunctionWrapper\"></a>\n###createFunctionWrapper\n _static_  function public\n\n\n---\n*Defined proxy.js* [Top](#top)\n\n\nCreates a function proxy for an object.\n\n\n        \n*Example*\n\n```javascript\n//create an object that can use properties or as a function through the new operator\nvar MyObject = comb.define(null, {\n    instance : {\n        hello : \"hello\",\n        constructor : function(){\n            this.args = comb.argsToArray(arguments);\n        }\n    }\n});\n\n//NOTE: this will not work properly for native objects like Date.\nvar createNewMyObject = function(){\n   try {\n     p = new MyObject();\n    } catch (ignore) {\n         //ignore the error because its probably from missing arguments\n    }\n    //Now lets take care of arguments supplied!!!\n    MyObject.apply(p, comb.argsToArray(arguments));\n    return p;\n};\n\n//This example creates an object with a world property but its not a function!\nvar handle = comb.createFunctionWrapper({world : \"world\"}, createNewMyObject, createNewMyObject);\n\nhandle.world //=> \"world\"\nvar a = handle(1);\na.hello;  //=>\"hello\"\na.args; //=> [1];\na = new handle(1,2);\na.hello; //=>\"hello\"\na.args; //=> [1,2];\n```\n\n     \n*Arguments*\n\n        \n * _obj_  : the object to proxy\n        \n * _handler_  : the handler to call when the object is used as a function\n        \n * _constructTrap_  : the funciton to use when using new on the object\n        \n * _opts_  : the prototype of the object.\n        \n     \n     \n\n\n    \n*Source*\n\n```javascript\nfunction (obj,handler,constructTrap,opts){\n   var args = comb.argsToArray(arguments), ret;\n   if (args.length != 4) {\n       opts = comb.isHash(args[args.length - 1]) ? args.pop() : null;\n       constructTrap = comb.isFunction(args[args.length - 1]) ? args.pop() : null;\n       handler = comb.isFunction(args[args.length - 1]) ? args.pop() : null;\n   }\n   if (comb.isUndefined(obj)) throw new Error(\"obj required when using create function wrapper\");\n   if (comb.isFunction(constructTrap) && !comb.isFunction(handler)) {\n       ret = Proxy.createFunction(handlerMaker(obj), constructTrap);\n   } else {\n       ret = Proxy.createFunction(handlerMaker(obj), handler, constructTrap);\n   }\n   if (opts) {\n       Proxy.setPrototype(ret, comb.isHash(opts) ? opts : opts.prototype);\n   }\n   return ret;\n}\n```\n    \n    \n  \n<a name=\"comb_executeInOrder\"></a>\n###executeInOrder\n _static_  function public\n\n\n---\n*Defined promise.js* [Top](#top)\n\n\nThis method allows one to code asynchronous code in a synchronous manner.\n\n<p>\n    <b>\n    Using Object.define[rest of name] on objects passed will result in unexpected behavior.</br>\n    Enumerating passed in object keys is not currently supported. i.e for in loops on objects.\n    using array enumeration methods will work though!!\n    </b>\n</p>\n\n\n        \n*Example*\n\n```javascript\nvar staticValueFunction = function (value) {\n     return comb.argsToArray(arguments).join(\" \");\n};\n\nvar promiseValueFunction = function (value) {\n     var ret = new comb.Promise();\n     setTimeout(comb.hitch(ret, \"callback\", comb.argsToArray(arguments).join(\" \")), 100);\n     return ret;\n};\n\nvar hash = {\n     staticValueFunction:staticValueFunction,\n     promiseValueFunction:promiseValueFunction\n};\n\nvar p = comb.executeInOrder(hash, staticValueFunction, promiseValueFunction, function (hash, staticValueFunction, promiseValueFunction) {\n    var toBe = staticValueFunction(promiseValueFunction(\"to\"), \"be\");\n    var notToBe = hash.promiseValueFunction(\"or\", hash.staticValueFunction(\"not\", toBe));\n    return hash.promiseValueFunction(toBe, notToBe);\n});\np.addCallback(function(ret){\n    console.log(ret); //=>\"to be or not to be\"\n});\n```\n\n     \n*Arguments*\n\n        \n * _args_  : variable number of objects.\n        \n * _cb_  : the function to callback to execute in order\n        \n     \n     \n*Returns*\n        \n *  comb.Promise\n        \n     \n\n\n    \n*Source*\n\n```javascript\nfunction (args,cb){\n   args = comb.argsToArray(arguments);\n   cb = comb.isFunction(args[args.length - 1]) ? args.pop() : null;\n   var ret = new Promise();\n   if (cb) {\n       var stack = [];\n       var newArgs = args.map(function (a) {\n           return [a, getHandler(a, stack)];\n       });\n       var cbRet = cb.apply(null, newArgs.map(function (h) {\n           return h[1];\n       }));\n       executeStack(stack, newArgs).then(function (results, pMap) {\n           if (comb.isUndefined(cbRet)) {\n               ret.callback(results);\n           }\n           else {\n               var cbResults;\n               if (comb.isArray(cbRet)) {\n                   cbResults = cbRet.map(\n                       function (arg) {\n                           return getValueFromArrayMap(arg, pMap, newArgs);\n                       }).filter(function (r) {\n                           return !comb.isUndefined(r)\n                       });\n               } else if (comb.isHash(cbRet)) {\n                   cbResults = {};\n                   for (var i in cbRet) {\n                       cbResults[i] = getValueFromArrayMap(cbRet[i], pMap, newArgs);\n                   }\n               } else if (comb.isProxy(cbRet)) {\n                   cbResults = getValueFromArrayMap(cbRet, pMap, newArgs);\n               } else {\n                   cbResults = cbRet;\n               }\n               ret.callback(cbResults);\n           }\n       }, hitch(ret, \"errback\"));\n   } else {\n       ret.callback();\n   }\n   return ret;\n       \n}\n```\n    \n    \n  \n<a name=\"comb_handlerProxy\"></a>\n###handlerProxy\n _static_  function public\n\n\n---\n*Defined proxy.js* [Top](#top)\n\n\nCreates a proxy for an object.\n\n        \n     \n*Arguments*\n\n        \n * _obj_  : object to proxy\n        \n * _opts_  : object with methods to define on the handler.\n        \n * _proto_  : \n        \n     \n     \n\n\n    \n*Source*\n\n```javascript\nfunction (obj,opts,proto){\n   opts = opts || {};\n   if (comb.isUndefined(proto)) {\n       return  Proxy.create(merge(handlerMaker(obj), opts));\n   } else {\n       return  Proxy.create(merge(handlerMaker(obj), opts), comb.isHash(proto) ? proto : proto.prototype);\n   }\n}\n```\n    \n    \n  \n<a name=\"comb_isProxy\"></a>\n###isProxy\n _static_  function public\n\n\n---\n*Defined proxy.js* [Top](#top)\n\n\n Determines if the object is a proxy or not.\n\n\n        \n     \n*Arguments*\n\n        \n * _obj_  : object to test\n        \n     \n     \n*Returns*\n        \n * <code>Boolean</code> true if it is a proxy false otherwise\n        \n     \n\n\n    \n*Source*\n\n```javascript\nfunction (obj){\n   var undef;\n   return obj !== undef && obj !== null && Proxy.isProxy(obj);\n}\n```\n    \n    \n  \n<a name=\"comb_methodMissing\"></a>\n###methodMissing\n _static_  function public\n\n\n---\n*Defined proxy.js* [Top](#top)\n\n\nCreates a method missing proxy for an object.\n<b>NOTE:</b> This method does not gurantee that the property will be used as a function call.\n\n\n        \n*Example*\n\n```javascript\nvar x = {hello:function () {return \"hello\"}, world:\"world\"};\n var xHandler = comb.methodMissing(x, function (m) {\n             //you can do more interesting stuff in here!\n              return function () {\n                  return [m].concat(comb.argsToArray(arguments));\n              }\n  });\n xHandler.hello(); //=> \"hello\"\n xHandler.world //=> \"world\"\n xHandler.someMethod(\"hello\", \"world\"); //=> [ 'someMethod', 'hello', 'world' ]\n```\n\n     \n*Arguments*\n\n        \n * _obj_  : object to wrap with a method missing proxy\n        \n * _handler_  : handle to call when a property is missing\n        \n * _proto_  : \n        \n * _opts_ <code>Object</code> : prototype to assign to the proxy\n        \n     \n     \n*Returns*\n        \n * <code>Proxy</code> a proxy\n        \n     \n\n\n    \n*Source*\n\n```javascript\nfunction (obj,handler,proto){\n   proto = proto || {};\n   return  Proxy.create(merge(handlerMaker(obj), noSuchMethodHandler(obj, handler)), comb.isHash(proto) ? proto : proto.prototype);\n}\n```\n    \n    \n  \n\n\n\n<a name=\"comb_plugins_MethodMissing\"></a>\n##comb.plugins.MethodMissing\n\n[Top](#top)\n\n\nThis plugin exposes two instance properties:\n<ul>\n    <li><b>getMissingProperty</b> method called when a property is being retrieved and is not found on the current instance</li>\n    <li><b>setMissingProperty</b> method called when a property is being set and the property is not found on the current instance</li>\n</ul>\n\n        \n*Example*\n\n```javascript\nvar MyClass = comb.define(comb.plugins.MethodMissing, {\n    instance : {\n\n        constructor : function(){\n             this._attributes = {};\n        },\n\n        getMissingProperty : function(name){\n            return this._attributes[name];\n        },\n\n        setMissingProperty : function(name, value){\n            return this._attributes[name] = value;\n        }\n    }\n});\n```\n\n\n\n\n\n\n\n\n\n\n*Instance*\n\n  * [getMissingProperty](#comb_plugins_MethodMissing_prototype_getMissingProperty)\n\n  * [setMissingProperty](#comb_plugins_MethodMissing_prototype_setMissingProperty)\n\n\n###Constructor\n\n*Defined plugins/MethodMissing.js* [Top](#top)\n     \n\n\n\n  \n  \n<a name=\"comb_plugins_MethodMissing_prototype_getMissingProperty\"></a>\n###getMissingProperty\n function public\n\n\n---\n*Defined plugins/MethodMissing.js* [Top](#top)\n\n\nMethod called to retrieve a property that is not found on the current instance of the object\n\n        \n     \n*Arguments*\n\n        \n * _name_  : the name of the property to retrieve.\n        \n     \n     \n\n\n    \n*Source*\n\n```javascript\nfunction (name){\n   //return defaults\n   return undefined;\n           \n}\n```\n    \n    \n  \n<a name=\"comb_plugins_MethodMissing_prototype_setMissingProperty\"></a>\n###setMissingProperty\n function public\n\n\n---\n*Defined plugins/MethodMissing.js* [Top](#top)\n\n\nMethod called to set a property that is not found on the current instance of the object\n\n        \n     \n*Arguments*\n\n        \n * _name_  : the name of the property to set.\n        \n * _value_  : the value to set the property to.\n        \n     \n     \n\n\n    \n*Source*\n\n```javascript\nfunction (name,value){\n   //return defaults\n   return this[name] = value;\n           \n}\n```\n    \n    \n  \n\n\n  <h2>License</h2>\n\n<p>MIT <a href = https://github.com/c2fo/comb-proxy/raw/master/LICENSE>LICENSE</a><p>\n\n<h2>Meta</h2>\n<hr>\n<p>Code: <code>git clone git://github.com/c2fo/comb-proxy.git</code></br></p>\n\n\n\n",
  "_id": "comb-proxy@0.0.3",
  "_from": "comb-proxy@>=0.0.3"
}
